{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"getting-started/","title":"QUICK START","text":"<p>Install using pip</p> <pre><code>pip install emp-agents\n</code></pre>"},{"location":"getting-started/#basic-usage","title":"Basic Usage","text":"<p><code>emp_agents</code> is a lightweight framework that abstracts the tools integrations and apis for multiple popular LLM providers.  In order to use, you should make an account with openai or claude and setup your environment variables to use these api keys:</p> <pre><code># setup an openai api key\nexport OPENAI_API_KEY=\"sk-...\"\n# or use anthropic\nexport ANTHROPIC_API_KEY=\"sk-...\"\n</code></pre> <p>then you can start interacting with a model by creating a simple python script:</p> <pre><code>from emp_agents import AgentBase\n\nagent = AgentBase(\n    personality=\"you are a goofy, friendly AI that likes to make up new words\"\n)\n\nagent.run_sync()\n</code></pre>"},{"location":"getting-started/config/","title":"Config","text":"<p>An agent can be loaded from a config object, using the <code>PersistentAgentConfig</code> and an agent that inherits from the <code>emp_agents.agents.PersistentAgent</code> class.  This allows for an agent to be loaded via <code>PersistentAgent.from_config(config)</code>, where the config is an object of type <code>PersistentAgentConfig</code>.</p> <pre><code>from emp_agents.config.agent_config import PersistentAgentConfig\nfrom emp_agents.agents.persistentagent import PersistentAgent\n\nconfig = PersistentAgentConfig(\n    agent_id=\"test-agent-1\",\n    name=\"Test Agent\",\n    description=\"A test agent\",\n    default_model=\"gpt-3.5-turbo\",\n    prompt=\"You are a test assistant\",\n    tools=[],\n    requires=[],\n)\nagent = PersistentAgent.from_config(config)\n</code></pre>"},{"location":"getting-started/skills/","title":"Skills","text":"<p>Skills are a collection of tools that an agent can use to interact with the world.  They are defined by a class that implements the <code>SkillSet</code> class.</p> <p>you can define a skill as a class with multiple functions, each should be a staticmethod and should be decorated with <code>@view_action</code> or <code>@onchain_action</code> depending on whether it is a view or a function that interacts with a blockchain.</p> <pre><code>class MathSkill(SkillSet):\n    \"\"\"A skill for performing basic math operations\"\"\"\n\n    @view_action\n    @staticmethod\n    async def add(a: int, b: int) -&gt; int:\n        \"\"\"Add two integers\"\"\"\n        return a + b\n\n    @view_action\n    @staticmethod\n    async def subtract(a: int, b: int) -&gt; int:\n        \"\"\"Subtract two integers\"\"\"\n        return a - b\n</code></pre> <p>This can then be utilized by an agent by providing it to the agent's <code>skills</code> parameter.</p> <pre><code>from emp_agents import AgentBase\n\nagent = AgentBase(\n    prompt=\"You are a helpful assistant that can perform basic math operations\",\n    skills=[MathSkill],\n)\n</code></pre>"},{"location":"getting-started/tools/","title":"Using Tools","text":"<p>A key capability of agent systems is their ability to interact with external data sources and services through tool integrations. This framework provides a flexible and robust architecture for managing these integrations. Tools can be dynamically added to or removed from agents as needed, and related tools can be logically grouped into reusable <code>Skill</code> objects to promote modularity and maintainability.</p> <p>Imagine you have two functions you want the agent to be able to call:</p> <pre><code>import httpx\nimport requests\n\n\ndef get_lyrics(artist: str, song: str) -&gt; str:\n    url = f\"https://api.lyrics.ovh/v1/{artist}/{song}\"\n    response = requests.get(url)\n    return response.json()[\"lyrics\"]\n\n\nasync def get_cat_fact() -&gt; str:\n    url = \"https://catfact.ninja/fact\"\n    async with httpx.AsyncClient() as client:\n        response = await client.get(url)\n    return response.json()[\"fact\"]\n</code></pre> <p>Tip</p> <p>Notice it supports both sync and async functions.</p> <p>Now we can add clear documentation to thse functions to enable our agent to understand how to use it.  The arguments must be annotated with the Doc object, and the function must have a docstring to annotate its intended use.  A tool should always return a string, as that is what the LLM is expecting from all prompts:</p> <pre><code>from typing import Annotated\nfrom typing_extensions import Doc\n\nimport requests\nimport httpx\n\ndef get_lyrics(\n    artist: Annotated[str, Doc(\"The name of the artist\")],\n    song: Annotated[str, Doc(\"The name of the song\")]\n) -&gt; str:\n    \"\"\"\n    Get the lyrics for a song by an artist\n    \"\"\"\n    url = f\"https://api.lyrics.ovh/v1/{artist}/{song}\"\n    response = requests.get(url)\n    return response.json()[\"lyrics\"]\n\n\nasync def get_cat_fact() -&gt; str:\n    \"\"\"\n    Get a random cat fact\n    \"\"\"\n    url = \"https://catfact.ninja/fact\"\n    async with httpx.AsyncClient() as client:\n        response = await client.get(url)\n    return response.json()[\"fact\"]\n</code></pre> <p>We can now construct an agent that has access to these tools. The agent will be able to understand the tools' functionality through their documentation and type hints, and can use them appropriately in conversations:</p> <pre><code>from emp_agents import AgentBase\n\n\nagent = AgentBase(\n    prompt=\"You are a helpful assistant that can provide song lyrics and cat facts\",\n    personality=\"You are very serious, and keep your responses very brief and professional\",\n    tools=[get_lyrics, get_cat_fact]\n)\n</code></pre>"},{"location":"purpose/rationale/","title":"Purpose","text":""},{"location":"purpose/rationale/#what-makes-this-framework-different","title":"What makes this framework different?","text":"<p>Tools integrations represent the most critical path forward for developers working with AI. As AI models continue to evolve and improve, the ability to effectively manage and control how these systems interact with external tools and services becomes increasingly important. The framework's primary focus is on providing developers with robust tools integration capabilities that enable precise control over AI system interactions.</p> <p>While AI models themselves are powerful, their true potential is realized through carefully managed integrations with existing systems and services. This framework emphasizes the importance of tools management by providing a structured approach to defining, organizing, and controlling tool interactions. By focusing on tools integration management, developers can ensure their AI implementations are both powerful and predictable.</p> <p>Security, reliability, and controlled deployment are key benefits of our tools-first approach. Through fine-grained control over what actions an AI can take and what data it can access, developers can carefully orchestrate AI capabilities within their applications. This approach enables responsible AI deployment while maintaining the flexibility needed to adapt to evolving AI technologies and integration requirements.</p>"},{"location":"purpose/rationale/#focus","title":"Focus","text":"<p>We also have an explicit focus on tooling for blockchain integrated agents.  This framework is not opinionated exclusively for blockchain use cases, but we believe this is a critical area of development and will focus our tools integration on making agents that can work well with popular data feeds, blockchain protocols and social media platforms.  Blockchain agents also have a few expected capabilities:</p> <p>Onchain Actions: Agents should be able to make onchain actions, such as sending transactions to a blockchain. Onchain Data: Agents should be able to retrieve data from a blockchain. Social Interactions: Agents should be able to interact with social media platforms.</p> <p>I woul also include a few other capabilities that are more traditional data wrangling behaviors:</p> <p>Extract Data: Agents should be able to extract data from a website or other source. Transform Data: Agents should be able to transform data into a usable format. Load Data: Agents should be able to load data into a database or other storage.</p> <p>Since an agent will typically be working directly with text, because able to provide the information to the agent as a jsonnd or csv file allows the agent to work with the information directly.</p>"},{"location":"skills/","title":"Index","text":"<p>As described in the skills guide, skills are modular tool collections that can be easily added to an agent to provide topic-specific functionality. We believe that well-curated, dynamically allocated tools are crucial for improving LLM performance, and skills provide a simple way to organize related tools into cohesive groups.</p>"},{"location":"skills/basic_wallet/","title":"Basic Wallet","text":"<p>The SimpleWalletSkill provides basic wallet functionality for managing private keys and addresses. It stores the private key in memory using context variables.</p> <p>The wallet skill consists of the following tools:</p> <ul> <li><code>create_wallet</code>: Creates a new private key wallet</li> <li><code>set_private_key</code>: Sets an existing private key</li> <li><code>get_private_key</code>: Retrieves the current private key</li> <li><code>clear_private_key</code>: Clears the stored private key</li> <li><code>get_address</code>: Gets the wallet address for the current private key</li> </ul> <p>The <code>create_wallet</code> tool generates a new private key wallet and stores it in memory. It returns a message containing both the wallet address and private key.</p> <p>The <code>set_private_key</code> tool allows you to import an existing private key. It takes one parameter:</p> <ul> <li><code>private_key</code>: The private key string to import</li> </ul> <p>The tool returns a success message when the key is set.</p> <p>The <code>get_private_key</code> tool retrieves the currently stored private key. If no key is set, it returns \"No private key set\".</p> <p>The <code>clear_private_key</code> tool removes the stored private key from memory. It returns a confirmation message when complete.</p> <p>The <code>get_address</code> tool derives and returns the wallet address for the currently stored private key. If no key is set, it returns \"No private key set\".</p>"},{"location":"skills/dexscreener/","title":"DexScreener","text":"<p>The DexScreenerSkill provides functionality for interacting with the DexScreener API to get information about trading pairs and tokens across different chains.</p> <p>The skill consists of the following tools:</p> <ul> <li><code>search_pairs</code>: Search for trading pairs matching a query</li> <li><code>get_pair_by_chain</code>: Get pair info for a specific chain and pair address</li> <li><code>find_pairs_by_tokens</code>: Find trading pairs by token addresses</li> <li><code>get_token_profiles</code>: Get latest token profiles</li> <li><code>get_latest_boosted_tokens</code>: Get recently boosted tokens</li> <li><code>get_top_boosted_tokens</code>: Get tokens with most active boosts</li> </ul> <p>The <code>search_pairs</code> tool searches for trading pairs matching a query string. It takes one parameter:</p> <ul> <li><code>query</code>: The search query to find trading pairs</li> </ul> <p>The tool is rate-limited to 300 requests per minute.</p> <p>The <code>get_pair_by_chain</code> tool retrieves pair information for a specific chain and pair address. It takes two parameters:</p> <ul> <li><code>chain_id</code>: The chain to search on (ethereum, solana, arbitrum, base, or bsc)</li> <li><code>pair_id</code>: The pair contract address</li> </ul> <p>The tool is rate-limited to 300 requests per minute.</p> <p>The <code>find_pairs_by_tokens</code> tool finds trading pairs by token addresses. It takes one parameter:</p> <ul> <li><code>token_addresses</code>: List of token addresses (maximum 30)</li> </ul> <p>The tool is rate-limited to 300 requests per minute.</p> <p>The <code>get_token_profiles</code> tool retrieves the latest token profiles.</p> <p>The tool is rate-limited to 60 requests per minute.</p> <p>The <code>get_latest_boosted_tokens</code> tool gets information about recently boosted tokens.</p> <p>The tool is rate-limited to 60 requests per minute.</p> <p>The <code>get_top_boosted_tokens</code> tool retrieves tokens with the most active boosts.</p> <p>The tool is rate-limited to 60 requests per minute.</p>"},{"location":"skills/simulacrum/","title":"Simulacrum","text":"<p>Coming Soon!</p>"},{"location":"skills/twitter/","title":"Twitter Skill","text":"<p>The Twitter skill provides functionality for interacting with the Twitter (X) API. It allows you to make tweets, create polls, reply to tweets, and post tweets with images.</p>"},{"location":"skills/twitter/#methods","title":"Methods","text":""},{"location":"skills/twitter/#make_tweet","title":"make_tweet","text":"<p>Makes a simple text tweet.</p> <p>Parameters: - <code>content</code> (str): The content of the tweet to be made</p> <p>Returns: String confirming tweet was submitted</p>"},{"location":"skills/twitter/#make_tweet_with_image","title":"make_tweet_with_image","text":"<p>Makes a tweet containing both text and an image.</p> <p>Parameters: - <code>content</code> (str): The content of the tweet to be made - <code>image_url</code> (str): URL of the image to include in the tweet</p> <p>Returns: String confirming tweet was submitted</p>"},{"location":"skills/twitter/#make_poll","title":"make_poll","text":"<p>Creates a Twitter poll.</p> <p>Parameters: - <code>content</code> (str): The content/question for the poll - <code>duration_minutes</code> (int): How long the poll should run for in minutes - <code>options</code> (list[str]): List of poll options for users to vote on</p> <p>Returns: String confirming poll was created</p>"},{"location":"skills/twitter/#reply_to_tweet","title":"reply_to_tweet","text":"<p>Replies to an existing tweet.</p> <p>Parameters: - <code>tweet_id</code> (int): The ID of the tweet to reply to - <code>content</code> (str): The content of the reply tweet</p> <p>Returns: String confirming reply was submitted with the tweet ID</p>"},{"location":"skills/uniswap/","title":"Uniswap","text":"<p>An example skill is the UniswapSkill, which allows for interacting with the Uniswap protocol.</p> <p>The Uniswap skill currently consists of two tools:</p> <ul> <li><code>get_price</code>: Get the price of a token in USD</li> <li><code>swap</code>: Swap an exact amount of ETH for tokens</li> </ul> <p>The <code>get_price</code> tool can be used to get the price of a token in terms of another token on Uniswap V2. It takes the following parameters:</p> <ul> <li><code>network</code>: The network to query the price on. Can be one of: \"ethereum\", \"arbitrum\", or \"base\"</li> <li><code>token_in</code>: The address of the token you want to swap from</li> <li><code>token_out</code>: The address of the token you want to swap to</li> </ul> <p>The tool returns the price as a JSON string containing a \"price\" field with the numeric price value.</p> <p>The <code>swap</code> tool can be used to swap tokens on Uniswap V2. It supports three types of swaps:</p> <ul> <li>ETH to tokens</li> <li>Tokens to ETH</li> <li>Tokens to tokens</li> </ul> <p>The tool takes the following parameters:</p> <ul> <li><code>network</code>: The network to execute the swap on (\"ethereum\", \"arbitrum\", or \"base\")</li> <li><code>input_token</code>: The address of the token to swap from. Use <code>None</code> if swapping from ETH</li> <li><code>output_token</code>: The address of the token to swap to. Use <code>None</code> if swapping to ETH</li> <li><code>amount_in</code>: The amount of input tokens to swap</li> <li><code>recipient</code>: The address that will receive the output tokens</li> <li><code>slippage</code>: The maximum acceptable slippage percentage (e.g. 0.05 for 5%)</li> <li><code>deadline</code>: Optional Unix timestamp deadline for the swap. If not provided, defaults to 1 minute from now</li> </ul> <p>The tool returns the transaction hash of the executed swap.</p>"}]}